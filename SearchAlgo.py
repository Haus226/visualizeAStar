from math import inf, sqrt
import random
from queue import PriorityQueue

sqrtof2 = sqrt(2)

"""
A* algorithm to find path between the two given coordinates in the given map 
"""
def initDistance(map_, start):
    """
    Initialize all the distance of the other nodes from the start node
    :param map_: Your map
    :param start: Coordinate of start node in tuple
    :return: A dictionary which record all the distances
    """
    distance = {start : 0}
    for row in range(len(map_)):
        for column in range(len(map_[row])):
            if (row, column) != start:
                distance[(row, column)] = inf
    return distance

def NoBlocked(map_, node) -> bool:
    """
    Check whether the given coordinate is blocked
    :param map_: Your map
    :param node: Your node wish to be checked
    :return: True if not blocked else False
    """
    if map_[node[0]][node[1]]:
        return True
    return False

def inMap(map_, node):
    """
    Ensure the given node is not out of the map
    :param map_: Your map
    :param node: Your node
    :return: True if node is in the map else False
    """
    if 0 <= node[0] < len(map_) and 0 <= node[1] < len(map_[0]):
        return True
    return False

def CalculateHeuristic(node, des, type:str="sld"):
    """
    Calculate the value of Heuristic function for A*
    :param node: The coordinate of start node in tuple
    :param des: The coordinate of destination node in tuple
    :param type: Type of heuristic function :
                 "Euclidean Distance", "Manhattan Distance", "Chebyshev Distance", "Diagonal Distance"
    :return: Value of heuristic
    """
    if type == "sld":
        return sqrt(
        ((node[0] - des[0]) ** 2) + ((node[1] - des[1]) ** 2)
    )

    elif type == "mht":
        return abs(node[0] - des[0]) + abs(node[1] -des[1])

    elif type == "che":
        return max(abs(node[0] - des[0]), abs(node[1] - des[1]))

    elif type == "dia":
        dx = abs(node[0] - des[0])
        dy = abs(node[1] - des[1])
        return (dx + dy) + ((sqrtof2 - 2) * min(dx, dy))

    elif type == "0":
        return 0

def Action(map_, node, des, h="euc", direction=None):
    """
    Return children or the states generated by given node
    :param map_: Your map
    :param node: The parent node
    :param des: The destination node
    :param h: The heuristic function you want:
              "sld", "mht", "che", "dia"
    :param direction: The directions which the node can move:
                      "up", "down", "left", "right",
                      "left-up", "left-down", "right-up", "right-down"
    :return: The dictionary contain coordinate of children as key while heuristic value as value
    """
    children = {}
    actions = {"up": (node[0] - 1, node[1]),
               "down": (node[0] + 1, node[1]),
               "right": (node[0], node[1] + 1),
               "left": (node[0], node[1] - 1), }
    if direction == 8:
        actions.update({
            "left down": (node[0] + 1, node[1] - 1),
            "left up": (node[0] - 1, node[1] - 1),
            "right up": (node[0] - 1, node[1] + 1),
            "right down": (node[0] + 1, node[1] + 1)
        })
    for action in actions:
        if inMap(map_, actions[action]) and NoBlocked(map_, actions[action]):
            child = actions[action]
            heu = CalculateHeuristic(child, des, h)
            children[child] = heu
    return children

def AStar(map_, start, des, h="sld", d=8):
    """
    A* Algorithm
    :param map_: Your map
    :param start: The starting coordinate in tuple
    :param des: The destination coordinate in tuple
    :param h: Type of heuristic :"Euclidean Distance", "Manhattan Distance", "Chebyshev Distance", "Diagonal Distance"
    :param d: The directions which the node can move:
                "up", "down", "left", "right",
                "left-up", "left-down", "right-up", "right-down"
    :return: The path from start coordinate to destination coordinate
    """
    prQueue = PriorityQueue()
    prQueue.put((0, start))
    parent = {start: None}
    distance = initDistance(map_, start)
    explored = []
    prev_cost = {start : 0}
    while not prQueue.empty():
        ele = prQueue.get()
        dist, node = ele[0], ele[1]
        if node == des: break
        children = Action(map_, (node[0], node[1]), des, h, d)
        for child in children:
            if child not in explored:
                heu = children[child]
                prev = prev_cost[node]
                cost = map_[node[0]][node[1]]
                if heu + prev + cost < distance[child]:
                    prQueue.put((heu + prev + cost, child))
                    parent[child] = node
                    distance[child] = heu + cost + prev
                    prev_cost[child] = cost + prev
                explored.append(child)
                if child == des:
                    total_distance = prev_cost[des]
                    route = []
                    while des is not None:
                        route.insert(0, des)
                        prev = des
                        des = parent[des]
                    return route, explored, total_distance, len(explored)

    print("Current Heuristic : ", h)
    if h != "0":
        if prQueue.empty():
            print("No route founded !")
            return None
    total_distance = prev_cost[des]
    route = []
    while des is not None:
        route.insert(0, des)
        prev = des
        des = parent[des]
    return route, explored, total_distance, len(explored)


"""
Kruskal and Prim algorithm for Minimum Spanning Tree(MST)
"""
def __find(father, node):
    """
    Find the parent of the given node
    :param father: To update the dictionary
    :param node: The node you wish to find its parent
    :return: Parent node
    """
    if father[node] != node:
        father[node] = __find(father, father[node])
    return father[node]

def __merge(father, depth, node1, node2):
    father_x = __find(father, node1)
    father_y = __find(father, node2)
    if father_x == father_y:
        return
    if depth[father_x] < depth[father_y]:
        father[father_x] = father_y
    else:
        father[father_y] = father_x
        if depth[father_x] == depth[father_y]:
            depth[father_x] += 1

def Kruskal(v, e, min=True):
    father = {}
    depth = {}
    mst = []
    for node in v:
        father[node] = node
        depth[node] = 0
    cost = 0
    e.sort(reverse=not min)
    for edge in e:
        if __find(father, edge[1]) != __find(father, edge[2]):
            __merge(father, depth, edge[1], edge[2])
            mst.append(edge)
            cost += edge[0]
    print(cost)
    for r in mst:
        print(r)

def Prim(v, min=True):
    """
    Prim algorithm for MST
    :param v: A dictionary which vertex as key and edge as value i.e
              v[vertex] = [("C1", W1), ("C2, W2)...]
    :return: The cost for MST
    """
    begin = list(v)[0]
    prQ = PriorityQueue()
    visit = {}
    mst = []
    for vertex in v:
        visit[vertex] = False
    prQ.put((0, begin, begin))
    cost = 0
    while not prQ.empty():
        vertex = prQ.get()
        if visit[vertex[2]]:
            continue
        visit[vertex[2]] = True
        cost += vertex[0]
        mst.append(vertex)
        for child in v[vertex[2]]:
            if not visit[child[0]]:
                prQ.put((child[1] if min else -child[1], vertex[2], child[0]))


    print(cost if min else -cost)
    for r in mst[1:]:
        print(r)

def RandomMapGenerator(row, column):
    map_ = []
    for i in range(row):
        temp = []
        for j in range(column):
            temp.append(random.randint(0, 1))
        map_.append(temp)

    return map_

if __name__ == '__main__':

    # "For Prim Test:"
    v = {"A":[("B", 7), ("D", 5)],
         "B":[("C", 8), ("D", 9), ("E", 7), ("A", 7)],
         "C":[("E", 5), ("B", 8)],
         "D":[("E", 15), ("F", 6), ("B", 9), ("A", 5)],
         "E":[("F", 8), ("G", 9), ("C", 5), ("B", 7), ("D", 15)],
         "F":[("G", 11), ("D", 6), ("E", 8)],
         "G":[("E", 9), ("F", 11)]}
    # "For Kruskal Test:â€œ
    e = [
        (7, "A", "B"),
        (5, "A", "D"),
        (8, "B", "C"),
        (9, "B", "D"),
        (7, "B", "E"),
        (5, "C", "E"),
        (15, "D", "E"),
        (6, "D", "F"),
        (8, "E", "F"),
        (9, "E", "G"),
        (11, "F", "G")
    ]
    # Kruskal(v, e)
    Kruskal(v, e)
    Kruskal(v, e, False)
    Prim(v)
    Prim(v, False)
